+++
+++
<!-- markdownlint-disable MD034 -->
{{ image(url="https://github.com/denehoffman/ganesh", url_min="ganesh_logo.png", no_hover=true) }}

[`ganesh`](https://github.com/denehoffman/ganesh) (/ɡəˈneɪʃ/), named after the Hindu god of wisdom, provides several common minimization algorithms as well as a straightforward, trait-based interface to create your own extensions. This crate is intended to be as simple as possible. The user needs to implement the `Function` trait on some struct which will take a vector of parameters and return a single-valued `Result` ($f(\mathbb{R}^n)\to\mathbb{R}$). Users can optionally provide a gradient function to speed up some algorithms, but a default central finite-difference implementation is provided so that all algorithms will work out of the box.

Part of the difficulty of this project is the lack of well-documented implementations of some of the more useful algorithms, like the BFGS family. While I am not sure, I believe this might be the first pure Rust implementation of L-BFGS-B. If you look through other optimization crates, Python packages, or even C/C++ libraries, a common theme you'll find is that they mostly just bind the original FORTRAN code written for this algorithm. I wanted to write the algorithm from scratch for two reasons. First, it's a great way to learn the language, and it's very convenient to not have to worry about dependencies in external languages like FORTRAN. Second, I had a lot of trouble finding bounded optimizers for Rust. [argmin](https://github.com/argmin-rs), the most-downloaded optimization crate, [currently doesn't implement any constrained optimizers](https://github.com/argmin-rs/argmin/issues/137), although external solvers like [egobox](https://crates.io/crates/egobox-ego) and [cobyla](https://crates.io/crates/cobyla) can be used to accomplish this. [nlopt](https://crates.io/crates/nlopt) has a Rust wrapper that includes these algorithms (written in C), but I quit using it after one too many C-related exceptions that were all-but-impossible to track down or solve with Rust code.
